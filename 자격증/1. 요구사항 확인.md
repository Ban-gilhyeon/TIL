모든 정보는 블로그에서 공부한 것을 정리한 것 입니다.
출처 : https://starrykss.tistory.com/1605
# 소프트웨어 생명주기 모델(SDLC, Software Development Life Cycle)

## 소프웨어 생명 주기 (Software Life Cycle)
- <U>소프트웨어를 개발하기 위한</U> 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것
- 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물(DS, SDD, SRS )로 표현 
- 대표적인 생명 주기 모형
	- 폭포수 타입
	- 프로토 타입 모형
	- 나선형 모형
	- 애자일 모형


### 폭포수 모형(Waterfall Model)
- 이전 단계로 돌아갈 수 없다는 전제하에 <U>각 단계를 확실히 매듭짓고</U> 그 결과를 <U>철저하게 검토하여 승인 과정을 거친 후에 다음 단계</U>를 진행하는 개발 방법론
- **가장 오래되고 가장 폭 넓게 사용된 전통적인 소프트웨어 생명 주기 모형
- 고전적 생명 주기 모형이라고 함
- 모형을 적용한 경험과 성공 사례가 많음
- 각 단계가 끝난 후에는 담 단계를 수행하기 위한 결과물이 명확하게 산출되어야 함

### 프로토타입 모형(Prototype Model, 원형 모형)
- 사용자의 요구사항을 파악하기 위해 실제 개발될 소프트웨어에 대한 **견본품(Prototype)을 만들어 최종 결과물을 예측하는 모형**
- 견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발(인터페이스 위주)

### 나선형 모형(Spiarl Model, 점진적 모형)
- 나선을 따라 돌듯 **여러번의 소프트웨어 개발 과정을 거쳐 점진적으로** 완벽한 최종 소프트웨어를 개발하는 모형
- **보햄(Bohem, 보혐 행님 아님ㅋ)** 이 제안
- `폭포수 모형`과 `프로토 타입 모형`의 `장점`에 **위험 분석 기능을 추가
- 누락되거나 추가된 요구사항을 첨가할 수 있음 ( 점진적으로 개발하니까 )
- 유지보수 과정이 필요 없음
- 4가지 주요 활동(cycle)
	- 계획
	- 분석
	- 개발
	- 평가
![[Pasted image 20250408020208.png]]

### 애자일 모형(Agile Model)
- 애자일은 `민첩한`,`기민한`이라는 의미로, **고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형**
- 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭 ( SI에서 자주 쓸 듯)
- 폭포수 모형과 **대조적**
- 기업 활동 전반에 걸쳐 사용됨
- 대표적인 개발 모형
	- 스크럼(Scrum)
	- XP(eXtreme Programming)
	- 칸반(Kanban)
	- Lean
	- 기능 중심 개발(FDD : Feature Driven Development)

애자일 개발 4가지 핵심 가치 
- 프로세그와 도구보다는 개인과 상호작용에 더 가치를 둔다.
- 방대한 문서보다는 실해되는 SW에 더 가치를 둔다
- 계약 협상보다는 고객과 협업에 더 가치를 둔다.
- 계획을 따르기 보다는 변화에 반응하느 것에 더 가치르 둔다.

소프트웨어 공학
- 소프트웨어 공학(SE : Software Engineering)은 **`소프트웨어 위기를 극복하기 위한 방안으로 연구된 학문**
- 여러가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산겅 향상을 목적으로 한다.
- 소프트웨어 공학의 기본 원칙
	- 현대적인 프로그래밍 기술을 계속적으로 적용해야함.
	- 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 함.
	- 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 함

#### 스크럼(Scrum) 기법
- 팀이 중심이 되어 개발의 효율성을 높이는 기법
- 팀원 스스로가 스크럼 팀을 구성하고, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야함

	스크럼 팀
	![[Pasted image 20250408175128.png]]
	- 백로그(Backlog)  : 제품 개발에 필요한 요구사항을 모두 모아 우선순위를 부여해 놓은 목록
	- 이해관계자(Stakeholder) : 소프트웨어 개발과 관련해서 이해관계자는 소프트웨어 개발 의뢰자, 소프트웨어 개발자, 소프트웨어 사용자 등

	스크럼 개발 프로세스
	![[Pasted image 20250408180003.png]]
	![[Pasted image 20250408180016.png]]
	- 제품 백로그(Product Backlog) : 
		- 제품 개발에 필요한 모든 요구사항 (User Stroy)을 우선순위에 따라 나열한 목록
		- 개발 과정에서 새롭게 도출되는 요구사항으로 인해 계속 업데이트 됨
		- 제품 백로그에 작성된 사용자 스토리는 전체 일정 계획인 릴리즈 계획(Release Plan)을 수힙할 때 사용됨
	- 소멸 차트(Burn-down Chart)
		- 해당 스프린트에서 작업의 진행 상황을 확인할 수 있도록 시간의 경과에 따라 남은 작업 시간을 그래프로 표현한 것
		- 초기에 추정했던 전체 작업 시간은 작업이 진행 될 수록 점점 줄어(Burn-down)들게 됨
- 스크럼 개발을 진행할 때는 `계획`하여 `진행(스프린트)` 한 후 `회의`와 `검토`를 거쳐 `회고`함

#### XP(eXtreme Programming) 기법
- 빈번히 수정되는 `요구사항`에 유연하게 대응하기 위해 고객의 참여와 개발과정 반복 극대화 -> 개발 생산성을 높임
- 짧고 반복적인 개발주기, 단순한 설계, 릴리즈의 기간을 짧게 반복
- XP의 5대 핵심 가치
	- 의사소통
	- 단순성
	- 용기
	- 존중
	- 피드백
개발 프로세스 
계획 수립 -> 이터레이션 -> 승인 검사 -> 소규모 릴리즈

- 이터레이션 : 실제 개발 작업을 진행하는 과정
- 승인 검사 : 이터레이션 안에서 제품이 구현되면 테스트 진행 

XP의 주요 실천 방법
![[Pasted image 20250408183436.png]]

![[Pasted image 20250408184207.png]]
![[Pasted image 20250408184214.png]]
### 현행 시스템 파악
- 현행 시스템 파악은 **기존 시스템이 존재할 경우에만 수행**하며,
- 기존 구조/기능/환경 분석을 통해 **개선 방향과 요구사항 정의의 기반**을 마련한다.
**“개발 시작 전에, 뭘 만들지, 뭘 바꿀지 정확히 알아야 하니까 먼저 지금 시스템 상태부터 분석한다.”**
![[Pasted image 20250408184639.png]]

현행 시스템 파악 → 요구사항 정의 → 설계 → 구현 → 테스트 → 배포

### 개발 기술 환경 파악
OS, RDBMS, 미들웨어 등을 선정할 때 고려해야 할 사항 기술, `오픈소스` 사용 시 주의점 제시 

오픈소스 관련 요구사항 식별 시 고려 사항
- 라이선스의 종류
- 사용자 수
- 기술의 지속 가능성

### 요구사항 정의
- 정상적으로 운영되는데 필요한 제약 조건

요구사항의 유형
- 기능 요구사항 ( Functional Requirements)
- 비기능 요구사항(Non-Functional Requirements)
- 사용자 요구사항 (User Requirements)
- 시스템 요구사항(System Requirements)
![[Pasted image 20250408192712.png]]
![[Pasted image 20250408192735.png]]
#### 핵심 구분 요령
**기능 VS 비기능**
- 기능은 "이걸 할 수 있어야 한다."
-> 기술적 목표 
- 비기능은 "이걸 이렇게 잘 해야 한다"
-> 품질적 조건 
예 ) 
기능 : 로그인 기능 제공
비기능: 로그인 시 응답 시간 1초 이내

**기능/비기능 = 무엇 VS 어떻게**

**사용자 VS 시스템 요구사항**
- 사용자는 말 그대로 사용자 입장 -> 자연어 느낌
- 시스템은 그걸 개발자가 구현할 수 있도록 정제
예 )
사용자 : " 나는 버튼 하나로 결제했으면 좋겠어요"
시스템 : "걸제 프로세스를 하난의 API 호출로 구성"

**서용자/시스템 = 말한 사람 VS 구현할 사람 기준**

### 요구사항 개발 프로세스 
- 요구사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 구조화 된 활동
- 요구사항 개발 프로세스가 진행되기전 타당성 조사(Feasiblilty Study)가 선행
- 요구사항 개발은 `요구 공학(Requirement Engineering)`의 한 요소
![[Pasted image 20250408195146.png]]
#### 요구사항 도출 (Requirement Elicitation, 요구사항 수집)
- 요구사항을 어떻게 수집할 것인지 식별하고 이해하는 과정
- 개발자와 고객 사이의 관계가 만들어지고 `이해관계자(Stakeholder)`가 식별됨
- 소프트웨어 개발 생명주기 (SDLC) 동안 지속적으로 반복
- 요구사항을 도출하는 주요 기법
	- 청취와 인터뷰
	- 설문
	- 브레인스토밍
	- 워크샵
	- 프로토 타이핑(Prototyping)
		- 프로토타입을 통해 요구 분석을 수행하여 명세서를 산출하는 작업
	- 유스케이스 (Use Case) : 사용자의 요구사항을 기능 단위로 표현

#### 요구사항 분석 (Requirement Analysis)
- 요구사항 중 명확하지 않거나 모호한 부분을 반견하고 이를 걸러내기 위한 과정
- 요구사항의 타당성 조사, 비용과 일정에 대한 제약 설정
- 자료 흐름도 (DFD)
- 자료사전 (DD)

#### 요구사항 명세 (Requirement Specification)
- 분석된 요구사항을 바탕으로 모델을 작성하고 문서화

#### 요구사항 확인 (Requirement Validation, 요구사항 확인)
- 요구사항 명세서가 정확하고 완전하게 작성되어 있는지 검토
- 요구사항 관리 도구를 이용해 요구사항 정의 문서들에 대해 `형상관리(SCM)`를 수행한다

#### 요구공학(Requirement Engineering)
- 요구사항을 정의하고, 부넉 및 관리하는 프로세스를 연구하는 학문
- 프로젝트 실패를 최소화하는 것이 목표

#### 요구사항 명세 기법

![[Pasted image 20250408202839.png]]

- 정형 명세 기법 
	- 수학적 원리 기반
	- 수학적 기호, 정형화된 표기법 
	- 요구사항을 정확하고 간결하게 표현할 수 있음
	- **표기법이 어려워 사용자가 이해하기 어려움**
	- `VDM`, `Z`,`Perti-net`, `CSP`
- 비정형 명세 기법
	- 상태/기능/객체 중심
	- 자연어를 기반으로 서술, 다이어그램으로 작성
	- 요구사항의 대한 결과가 작성자에 따라 다를 수 있음 ( 일관성이 떨어진다)
	- 내용의 이해가 쉬움 -> 의사소통 용이함
	- `FSM`, `Decision Table`, `ER 모델링`, `State Chart`

#### 요구사항 분석
- SW 개발의 실제적인 첫 단계, **개발 대상에 대한 사용자의 요구사항을 이해하고 문서화**
- 사용자 요구의 타당성 조사, 비용과 일정에 대한 제약 설정
- 사용자의 요구를 정확하게 추출하여 목표를 정함

##### 구조적 분석 기법
- 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법
- **도형 중심**의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 파악하고 문서화
- **하향식 방법**을 사용하여 시스템을 세분화할 수 있음 
- 분석의 중복을 배제할 수 있음
- 주요 구조적 분석 기법 도구
- `자료 흐름도 (DFD)`
- `자료 사전(DD)`
- `소단위 명세서`
- `개체 관계도 (ERD)`
- `상태 전이도 (STD)`
- `제어 명세서`

##### 자료 흐름도 (DFD, Data Flow Diagram)
- **자료**의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법
- 차료 흐름 그래프, 버블 차트라고도 불림
###### 자료 흐름도 기본 기호 
![[Pasted image 20250413020817.png]]
![[Pasted image 20250413021236.png]]

##### 자료 사전 (DD, Data Dictionary)
- 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것
- 데이터를 설명하는 데이터, 데이터의 데이터, 메타 데이터 (Meta Data)
![[Pasted image 20250413021138.png]]

##### CASE와 HIPO
요구사항 분석용 CASE (자동화 도구)
- 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구
- SADT
	- 구조적 요구 분석을 하기 위해 **블록 다이어그램**을 채택한 자동화 도구
- SREM = RSL/REVS
	- TRW 사가 실시간 처리 SW 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 도구
	- RSL과 REVS를 사용하는 자동화 도구
		- RSL : 요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어
		- REVS : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 명세서를 출력하는 요구사항 분석기
- PSL / PSA
	- PSL : 문제(요구사항) 기술 언어
	- PSA : PSL로 기술한 요구사항을 분석하여 보고서를 출력하는 문제 분석기
	- 미시간 대학에서 개발
- TAGS
	- 시스템 공학 방법 응용에 대한 자동 접근 방법
	- 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구 
- HIPO(Hierarchy Input Process Output)
	- **분석 및 설계 문서화에 사용되는 기법** 시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 것
	- 하향식 SW 개발을 위한 문서화 도구
	- 기호 도표 등 사용으로 이해하기 쉬움
	- HIPO Chart : 시스템의 기능을 여러개의 `고유 모듈`로 분활하여 이들간의 인터페이스를 계층 구조로 표현 한 것
		- 가시적 도표(Visual Table of Contents, 도식 목차)
		- 총체적 도표(Overview Diagram, 총괄 도표, 개요 도표)
		- 세부족 도표(Detail Diagram, 상세 도표)

##### UML(Unified Modeling Language)의 개요
- 시스템 개발과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적인 **객체지향 모델링 언어**
- UML의 구성 요소
	- 사물 (Things)
	- 관계 (Relationships)
	- 다이어그램(Diagram)

##### 사물(Things)
- 다이어그램 안에서 관계가 형성될 수 있는 대상들
- 모델을 구성하는 가장 중요한 기본 요소
- 사물의 종류
	- 구조 사물
		- 시스템의 개념적, 물리적 요소를 표현
		- 클래스, 유스케이스, 컴포넌트, 노드 등
	- 행동 사물
		- 시간과 공간에 따른 요소들의 행위를 표현
		- 상호작용, 상태머신 등
	- 그룹 사물
		- 요소들을 그룹이로 묶어서 표현
		- 패키지
	- 주해 사물(Annotaton Things)
		- 부가적인 설명이나 제약조건 등을 표현
		- 노트

##### 관계 (Relationship)
- 사물과 사물 사이의 연관성을 표현
- 관계의 종류
	- 연관 관계
	- 집합 관계
	- 포함 관계
	- 일반화 관계
	- 의존 관계
	- 실체화 관계

연관(Association)
- 2개 이상의 사물이 서로 관련되어 있는 관계
- 사물 사이를 `실선`으로 연결하여 표현
- 방향성은 `화살표`로 표현
- 양방향 관계인 경우 화살표 생략
- `다중도`를 선 위에 표기
	- `다중도` : 연관에 참여하는 객체의 개수
![[Pasted image 20250415023725.png]]![[Pasted image 20250415023835.png]]
집합(Aggregation) 관계
- 하나의 사물이 다른 사물에 포함되어 있는 관계
- 포함하는 쪽 (전체)과 포함되는 쪽(부분)은 서로 `독립적`이다.
- 포함되는 쪽에서 포함하는 쪽으로 속이 `빈` 마름모를 연결하여 표현 
![[Pasted image 20250415025502.png]]
포함(Composition) 관계
- 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
- 포함하는 쪽과 포함되는 쪽은 서로 `독립 될 수 없고` 생명주기를 함께함
- 포함되는 쪽에서 포함하는 쪽으로 속이 `채워진` 마름모를 연결하여 표현
![[Pasted image 20250415025706.png]]
일반화(Generalization) 관계
- 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계
- 보다 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)이라 부른다
- 자식인 사물에서 부모인 사물쪽으로 속이 `빈` 화살표를 연결하여 표현
![[Pasted image 20250415025850.png]]
의존(Dependency)관계
- 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
- 사물과 다른 사물이 소유관계는 아니지만, 사물의 변화가 다른 사물에도 영향을 미치는 관계
- 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 `점선` 화살표를 연결하여 표현
![[Pasted image 20250415030036.png]]
실체화(Realization) 관계
- 할 수 있거나 해야하는 기능으로 서로 그룹화 한 관계
- 사물에서 기능쪽으로 속이 `빈` `점선` 화살표를 연결
![[Pasted image 20250415030136.png]]
##### UML - 다이어그램
다이어그램(Diagram)
- 사물과 관계를 도형으로 표현한 것
- `정적` 모델링에서는 주로 `구조적 다이어그램`을 사용
- `동적` 모델링에서는 주로 `행위 다이어그램`을 사용
![[Pasted image 20250415030404.png]]
![[Pasted image 20250415030416.png]]
##### 스테레오 타입
- UML에서 표현하는 기본 기능외에 `추가적인 기능`을 표현한 것
- `길러맷(Guilemet)`이라고 부르는 겹화살괄호(<< >>)사이에 표현할 형태를 기술
	- include : 연결된 다른 UML요소에 대해 포함관계에 있는 경우
	- extend : 확장관계
	- interface : 인터페이스 정의
	- exception : 예외를 정의
	- constructor : 생성자의 역할을 수행하는 경우

##### 유스케이스 다이어그램
기능 모델링
- 개발될 시스템이 갖춰야 할 기능을 사용자와 함껨 정리한 내용을 공유하기 위해 그림으로 표현하는 것
- 기능 모델링의 종류
	- 유스케이스 다이어그램
	- 액티비티 다이어그램

###### 유스케이스 다이어그램
- 개발될 시스템을 이용해 수행할 수 있는 기능을 `사용자의 관점`에서 표현한 것
- 외부 요소와 시스템 간의 상호작용을 확인할 수 있음
![[Pasted image 20250415031355.png]]
![[Pasted image 20250415031513.png]]
![[Pasted image 20250415031526.png]]
###### 활동 다이어그램
- `사용자의 관점`에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현
![[Pasted image 20250415031818.png]]
![[Pasted image 20250415031845.png]]
![[Pasted image 20250415031903.png]]
###### 클래스 다이어그램
정적 모델링
- 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것
![[Pasted image 20250415033235.png]]
![[Pasted image 20250415033304.png]]
###### 시퀀스 다이어그램
- 시스템이나 객체들이 `메세지`를 주고 받으며 `상호작용`하는 과정을 그림으로 표현
![[Pasted image 20250415033513.png]]
![[Pasted image 20250415033552.png]]

#### 동적 VS 정적 다이어그램 정리
![[Pasted image 20250415033205.png]]
![[Pasted image 20250415032421.png]]

동적 모델링 : 사용자와 개발자가 같이 요구사항 분석을 할 때 
정적 모델링 : 개발자가 이제 어떻게 구현하지? 를 초점으로

#### 소프트웨어 개발 방법론
소프트웨어 개발 방법론 
- 소프트웨어 개발, 유지보수 등에 필요한 수행 방법들과 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것
주요 소프트웨어 개발 방법론
 - 구조적 방법론
 - 정보공학 방법론
 - 객체지향 방법론
 - 컴포넌트 기반 (CBD) 방법론
 - 제품 계열 방법론
 - 애자일 방법론

##### 구조적 방법론
- 사용자의 요구사항을 파악하여 문서화하는 처리 중심의 방법론
- 복잡한 문제를 다루기 위해 `분할과 정복`원리를 
- 개발 절차
![[Pasted image 20250415162658.png]]


##### 정보공학 방법론
- 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 `자료` 중심의 방법론
- 대규모 정보 시스템을 구축하는데 적합하다.
- 개발 절차
![[Pasted image 20250415162950.png]]

##### 객체지향 방법론
 - 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론
 - **구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택**
 - 구성 요소
	 - 객체 : 데이터와 데이터를 처리하는 함수를 묶은 집합
	 - 클래스 : 공통된 속성과 연산을 갖는 객체의 집합
	 - 메세지 : `객체`들 간에 상호작용을 하는데 사용되는 수단
- 기본 원칙
	- 캡슐화 : 데이터를 처리하는 함수를 하나로 묶는 것
	- 정보 은닉 : 캡슐화에서 가장 중요한 개념, 다른 `객체`에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것 
	- 추상화 : 객체의 속성 중 가장 중요한 것에 중점을 두어 개략화 하는 것
	- 상속성 : 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
	- 다형성 : 하나의 메세지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력 
- 개발 절차
![[Pasted image 20250415163805.png]]

##### 컴포넌트 기반(CBD : Component Based Design) 방법론
- 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론
- 컴포넌트의 재사용(Reusablility)이 가능하여 시간과 노력을 절감
- 개발 절차
![[Pasted image 20250415164706.png]]

#### 소프트웨어 공학의 발전적 추세
##### 소프트웨어 재사용
- 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
- 방법
	- 합성 중심(Composition-Based)
		- 전자 칩과 같은 소프트웨어 부품, 블록을 만들어서 끼워 맞춰 소프트웨어를 완성 시키는 방법
		- `블록 구성 방법`
	- 생성 중심 (Generation-Based)
		- 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법
		- `패턴 구성 방법`
		- 예시 ) 
			- Spring initializr
			- JHispter, yeoman : 프로젝트 템플릿 생성기
			- DSL 
![[Pasted image 20250415170943.png]]

##### 소프트웨어 재공학(Software Reengineering)
- 기존 시스템을 이용하여 보다 나은 시스템을 구축, 새로운 기능을 추가하여 소프트웨어 성능을 향상 시키는 것 
- 엥? 완전 리팩토링이잖아?
	- ![[Pasted image 20250415172154.png]]
	- 따라서 재공학 >> 리팩토링 (재공학이 더 큰 범주에 있고 리팩토링을 포함하고 있음)

##### CASE(Computer Aided Software Engineering)
- 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것
- 주요기능
	- 생명주기 전 단계의 연결
	- 다양한 소프트웨어 개발 모형 지원
	- 그래픽 지원

##### 비용 산정 기법
소프트웨어 비용 결정 요소
![[Pasted image 20250415175505.png]]
소프트웨어 개발 비용은 시스템의 크기가 `크고` 신뢰도가 `높을 수록` 많이들고 개발 후기로 `갈수록` 적게 든다 

###### 하향식 비용 산정 기법
유사한 경험을 바탕으로 개발자들이 회의를 통해 비용 산정(비과학적)
- 전문가 감정 기법
- 델파이 기법
	- 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정

###### 상향식 비용 산정 기법
세부적인 작업 단위별로 비용을 산정한 후 집계 -> 전체 비용 산정
- LOC (원시 코드 라인 수) 기법
- 개발 단계별 인월수 기법
- 수학적 산정 기법

LOC (원시 코드라인 수, source Line Of Code) 기법
각 기능의 원시 코드 라인 수의 `비관치`, `낙관치`, `기대치`를 측정하여 예측치를 구하고 이를 이용하여 비용 산정
- 비관치 : 가장 많이 측정된 코드 라인 수 (Worst)
- 낙관치 : 가장 적게 측정된 코드 라인 수 (Best)
- 기대치 : 측정된 모든 코드 라인 수의 평균 (Average)
![[Pasted image 20250415181148.png]]
- 산정 공식
	- 노력(인월) = 개발 기간 * 투입 인원 = LOC/1인당 월 평균 생산 코드 라인 수
	- 개발 비용 = 노력 (인월) * 단위 비용 (1인당 월평균 인권비)
	- 개발 기간 = 노력(인월) / 투입 인원
	- 생산성 = LOC / 노력(인월)

개발 단계별 인원 수(EFfort Per Task) 기법
- LOC 기법을 보완하기 위한 기법, 기능을 구현 시키는데 필요한 노력을 생명 주기의 각 단계별로 산정

수학적 산정 기법
- `경험 추정 모형`, `실험적 추정` 모형이라고 함
- 개발 비용 산정의 자동화를 목표로 함
- 주요 기법
	- COCOMO 모형
	- Putnam 모형
	- 기능 점수(FP) 모형

COCOMO(COnstructive COst MOdel) 모형
- LOC에 의한 비용 산정 기법
- 비용 산정 결과는 프로젝트를 완성하는데 필요한 노력(Man-Month)으로 나타냄
- 보햄(Boehm)이 제안

COCOMO의 소프트웨어 개발 모형
 ![[Pasted image 20250415183000.png]]
 조직형 < 반분리형 < 내장형
 
Putman 모형
- 생명주기 전 과정 동안 사용될 노력의 분포를 예상하는 모형
- Rayleigh-Norden 고석의 노력 분포도를 기초
- `대형`프로젝트의 노력 분포 산정에 이용됨
- 개발 기간이 늘어날 수록 프로젝트 적용 인원의 노력이 감소

기능 점수(FP, Funtion Point) 모형
- 소프트웨어의 기능을 증대시키는 요인별로 가중치를 합산하여 **총 기능 점수** 산출하며 총 기능 점수와 영향도를 이용하여 FP를 산출 이를 이용하여 비용 산정
	- 총 기능 점수 : 개발의 규모, 복잡도, 난이도 등을 하나로 수치로 집약
- 알브레히트 제안
- 기능 증대 요인
	- 자료 입력
	- 정보 출력
	- 명령어
	- 데이터 파일
	- 외부 루틴과의 인터페이스

##### 프로젝트 일정 계획 
프로젝트 일정 계획에 사용되는 기능
- WBS(Work Breakdown Structure, 업무 분류 구조)
	- 개발 프로젝트 여러 개의 작은 관리 단위로 분할 하여 계층적으로 기술한 업무 구조
- PERT/CPM
	- 프로젝트의 지연을 방지하고 계획대로 진행되도록 일정을 계획하는 것
	- 대단위 계획의 조직적인 추진을 위해, 비용을 적게 사용하면서 최단시간 내 계획 완성을 위한 프로젝트 일정 방법
- 간트 차트

PERT(Program Evaluatuin and Review Techique, 프로그램 평가 및 검토 기술)
- 각 작업 별로 단계를 나눠 종료 시기 결정
	- 낙관적인 경우
	- 가능성이 있는 경우
	- 비관적인 경우
- 노드와 간선으로 구성되며, 원 노드에는 작업, 간선에는 낙관치, 기대치, 비관치를 표시
	- 낙관치 : 초 럭키
	- 기대치 : 예상대로군..
	- 비관치 : Worst
![[Pasted image 20250415191159.png]]
* A -> B : 2,5,14  => 낙관치 :2 , 기대치 :5, 비관치 :14 
* A -> B : 14 + (4 X 5) + 2 / 6  = 작업 예측치 : 6

CPM(Critical Path Method, 임계 경로 기법)
- 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
- 노드와 간선으로 구성된 네트워크
	- 노드 : 작업
	- 간선 : 작업 사이의 전후 의존 관계
- 원형 노드 : 각각의 작업을 의미, 작업 이름과 소요 시간 표시
- 박스 노드 : 이정표를 의미, 이름과 예상 완료 시간을 표시
![[Pasted image 20250415191908.png]]

##### 소프트웨어 개발 표준
- 개발단계에서 수행하는 품질 관리에 사용되는 국제 표준
- ISO/IEC 12207
- CMMI (능력 성숙도 통합 모델)
	- 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
- SPICE(소프트웨어 처리 개선 및 능력 평가 기준)
	- 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준