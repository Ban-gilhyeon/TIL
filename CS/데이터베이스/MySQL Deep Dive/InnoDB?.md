![[Pasted image 20251005012343.png]]
MySQL에서 사용하는 데이터베이스 엔진
트랜잭션 세이프 스토리지 엔진으로서 대용량 데이터를 처리할 때 많은 장점을 가지고 있음
- 트랜잭션 지원 : commit, begin, rollback
- ACID 보장 : 원자성, 일관성, 격리성, 지속성
- 외래키 지원 : 참조 무결성 보장
- 자동 복구 가능 : 비정상 종료 후 데이터 복구
- MVCC (Multi-Version Concurrency Control) : 동시성 처리 & 잠금 최소화
- 클러스터형 인덱스 : PK가 실제 데이터 저장 순서

### InnoDB 아키텍처

![[Pasted image 20251004234759.png]]

#### 메모리, 파일영역 
##### Buffer Pool
- 디스크의 데이터 파일이나 정보를 메모리에 캐시해두는 공간
- SELECT 시 버퍼 캐시에 해당 페이지가 없다면 ibdata(디스크 파일, 디스크에 저장하는 실제 파일)를 뒤져서 버퍼풀에 기록하고 결과값 반환
- INSERT 구문 발생 시 해당 데이터가 캐시가 안되어있으면, 캐시 생성 및 물리적인 파일에도 내용 기술
	- 변경된 데이터를 모아서 처리하기 때문에 (Batch) 랜덤한 디스크 작업의 횟수를 줄일 수 있다.
	- 더티페이지(메모리 층에서 수정되었는지 디스크에 업데이트 안된 데이터)는 주기적또는 특정 조건이 되면 체크포인트가 발생하는데 이때 Write thread(push)가 필요한 만큼의 데이터 페이지만 디스크로 기록
	- 체크포인트가 발생한다고 해서 버퍼풀의 모든 더티페이지가 디스크로 기록되는 것은 아니다
- 쓰기 작업을 지연시켜 일괄적으로 처리할 수 있게 도와주는 버퍼 역할
- --> 읽기 성능 최적화 ( 캐시 계층 ), 쓰기 버퍼(Batch) 용도
##### Undo 로그
- update, delete 시 변경되기 이전의 데이터를 보관하는 곳이다.
- Update 문을 실행하면 실제 데이터 파일에는 변경된 데이터가 저장
- 변경되지 이전의 데이터를 언두 영역에 백업
- 이 상태에서 commit을 하게 되면 상태가 그대로 유지
- rollback 시키면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구
##### Insert Buffer 
- 데이터가 insert, Update 될 때 데이터 파일만 변경되는 것이 아니라 인덱스 또한 변경되어야 함 그러나 인덱스 업데이트 작업은 디스크의 많은 자원을 소모하게 됨 -> Insert Buffer의 필요성
- 인덱스 변경이 필요할 때 인덱스 페이지가 버퍼풀에 있으면 바로 업데이트, 그렇지 않다면 이를 임시 공간에 저장해두고 바로 결과 반환 (임시 메모리)
- 임시로 저장되는 인덱스 레코드 조각은 이후 백그라운드 인서트 버퍼 머지 스레드에 의해 병합
##### Redo 로그 및 로그 버퍼
쿼리로 데이터를 변경할 때 순차적으로 변경된 내용을 기록하는 파일을 Redo 로그라고 함
- 대용량 작업에서 리두 로그 작업은 문제가 됨 이를 보안하기 위해 최대한 ACID 속성을 보정하는 수준에서 버퍼링하게 됨
- 로그 버퍼는 이러한 리두 로그 버퍼링에 사용되는 공간
- 설정 값이 클수록 디스크 사용량이 줄어 성능 향상, 시스템 다운 시 손실되는 트랜잭션 양 증가
- 크기가 작으면 로그 버퍼를 로그파일에 쓰기 위한 부하가 많이 발생 
##### 테이블 스페이스
 - 시스템 테이블 스페이스와 유저 테이블 스페이스 크게 두가지로 나뉜다.
 - 시스템 테이블 스페이스는 iddata1에 해당 유저 테이블 스페이스는 테이블명.ibd에 속함
 - 유저 테이블 스페이스에는 인덱스 파일과 데이터 파일이 속해 있고, 시스템 테이블에는 dictonary(테이블 정보 등) 및 undo등 적지 않은 내용들이 속해 있음
