: 기존에는 개발자가 클래스를 만들고 클래스를 사용하기 위해서는 생성자를 선언하여 Main 클래스에서 객체를 만들어 클래스 내부의 필드 및 메소드를 사용하는 것이 익숙하다 하지만 `Spring framework`가 개발자를 도우며 위의 관계에서 조금 달라지게 된다 이를 **IoC**라 한다. 

## IoC (Inverstion of Controll : 제어의 역전)
 : 메소드나 객체의 호출 작업을 개발자가 결정하는 것이 아니라 외부에서 결정되는 것을 의미 <br>
`라이브러리`를 사용하는 애플리케이션 코드는 **애플리케이션 흐름**을 직접 제어 
`프레임워크`는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용 됨 프레임워크가 흐름을 주도하면서 개발자가 만든 애플리케이션 코드를 사용함 <br>
에플리케이션 코드가 프레임워크가 짜놓은 `틀`에서 **수동적**으로 동작함 이를 `Hollywood Principle`이라고 함

정리하자면 `Spring framework`는 개발자가 비지니스 로직에 집중할 수 있게 객체의 생성부터 생명 주기 등 모든 객체에 대한 제어권을 가지고 개발자가 편하게 사용할 수 있도록 도와줌 이를 IoC(제어의 역전)이라 부름 약간의 반전술식..ㅋㅋ

하지만 IoC는 개념의 이름이고 이를 구현한 것은 `IoC컨테이너` 라고 함
**IoC컨테이너(spring에서는 ApplicationContext)** 는 `DI`와 `DL`의 의해 구현된다는 사실 ..
![[Pasted image 20240915160142.png]]

## IoC Container
스프링 컨테이너가 관리하는 객체르 `빈(Bean)`이라고 하고 이 `빈`들을 관리한다는 의미로 컨테이너를  `빈팩토리(BeanFactory)`라고 부름
- 객체의 생성과 객체 사이의 런타임 관계를 `DI`관점에서 볼 때 컨테이너를 `BeanFactory`라고 함
- `BeanFactory`에 여러가지 컨테이너 기능을 추가한 `에플리케이션컨텍스트(ApplicationContext)`가 있음
![[Pasted image 20240915162711.png]]
### BeanFactory
- `BeanFactory` 계열의 인터페이스만 구현한 클래스는 단순히 컨테이너 객체를 생성하고 `DI`를 처리하는 기능만 제공
- Bean을 등록, 생성, 조회, 반환 관리를 함
- 팩토리 디자인 패턴을 구현한 것으로 BeanFactory는 빈을 생성하고 분배하는 책임을 지는 클래스임
- Bean을 조회할 수 있는 getBean() 메소드가 정의되어 있음
- 보통은 BeanFactory를 바로 사용하지 않고 이를 확장한 ApplicationContext를 사용함
### ApplicationContext
- 일종의 IoC Container
- `Ioc Container`는 객체에 대한 생성과 조합이 가능하게 하는 `프레임워크`임
![alt text](image-1.png)

- `Spring`에서는 IoC 컨테이너를 `Application Context`인터페이스로 제공함
- `bean`스프링(IoC container)이 관리하는 객체를 @Bean으로 관리
- `bean`들을 관리한다는 의미로 컨테이너를 빈 팩토리(BeanFactory)라고 부름
- 스프링의 `Application Context`는 실제 만들어야 할 bean정보를 **configuration Metadata(설정 메타데이터)** 를 이용해서 IoC 컨테이너에 의해 관리되는 객체들을 생성하고 구성함 
	- 에플리케이션에서 객체들의 `도면`이라고 볼 수 있음 
## Dependency(의존관계)란
의존 관계는 의존 대상 B가 변하면 그것이 A에 영향을 미칠 때 **A는 B와 의존관계**라고 함
-  `자동차`는 `타이어`가 부품으로 들어감 (의존함)
- `타이어`를 바꾼다면 `자동차`의 타이어도 수정해야 함 
- 타이어의 변화가 자동차에 영향을 미쳤기 때문에 자동차는 타이어를 의존한다고 할 수 있음

```java
public class Car {  
	private Tire hankookTire;
    public Car() {  
        this. hankookTire = new Tire(); // 너무 강한 결합도 
    }
```

이러한 코드는 문제점을 가짐 
- 두 클래스의 결합성이 높다
- 객체들 간의 관계가 아닌 클래스 간의 관계가 맺어짐 
## DI (Dependency Injection : 의존관계 주입)
공식 문서를 직역하자면 
- `DI`는 IoC의 특수한 형태로, 객체는 생성자 인수, 팩토리 매서드에 대한 인수 또는 팩토리 매서드에서 생성되거나 반환된 후 객체 인스턴스에 설정된 송석을 통해서만 종속성(즉, 객체가 작업하는 다른 객체)을 정의한다.
라는데 솔직히 와닿지는 않는다 <br>
DI란 
: 외부에서 두 객체 간의 관계를 결정해주는 **디자인패턴**으로 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임시에 관계를 동적으로 주입하여 **유연성**을 확보하고 결합도를 낮출 수 있게 함

-> 의존관계 주입은 의존 관계를 외부에서 결정(주입) 해주는 방식을 말함
```Java
public class Car{
	private Tire tire;

//@Autowired
	public Car(Tire  hankokTire){
		this.tire = hankokTire; 
	}
}
```

위와 같이 생성자에 의존성을 포함시켜 객체를 생성하는 방법을 **생성자 주입**이라고 함 <br>
어떤 객체를 주입할지는 런타임 시점에 스프링 컨테이너(외부)가 결정하며 컨테이너는 객체 래퍼랜스를 제공함 ~~또한 개인적인 생각으로 싱글톤의 역할도 할 수 있다고 생각함~~

## DL(Dependency Lookup : 의존관계 검색)
 : 의존관계가 필요한 객체에서 직접 검색하는 방식을 말함
 자신이 필요로하는 의존 오브젝트를 능동적으로 찾지만, 어떤 클래스의 오브젝트를 이용할지를 결정하지는 않음 (IoC 방식이기 때문에) <br>
의존관계 검색은 어떤 오브젝트를 사용할지 결정하는 것과 오브젝트의 생성은 `외부 컨테이너`에게 맡기지만, 이를 가져올 떄는 생성자를 통한 주입 대신 **스스로 컨테이너에게 요청하는 방법**을 사용함 
따라서 의존관계가 필요한 객체(클라이언트)는 의존하고자 하는 인터페이스 타입만 지정해서 검색할 뿐 해당 인터페이스를 구현한 구체적인 클래스 객체에 대한 결정과 해당 객체 대한 생명주기는 IoC 컨테이너에서 책임을 짐 

### getBean()
의존 관계 검색에 사용되는 대표적 메소드 
```Java
	public class Car{
		AnnotationConfigApplicationContext ac = 
			new AnnotationConfigApplicationContext(AppConfig.class);
		private Tire tire;

		public Car(){
			this.tire = ac.getBean(Tire.class);
		}
	}
```
실행시켜보면 앞의 DI와 동일하게 실행이 되는 것을 알 수 있음 

그런데 의존 관계 주입이 코드가 훨씬 깔끔함 -> 왜 씀?

의존관계 검색 방법은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타나게 됨
애플리케이션 컴포넌트가 컨테이너와 같은 성격이 다른 오브젝트에 의존하게 되므로 바람직 하지 않음
또한 스프링은 IoC와 DI 컨테이너를 적용했다고 하더라도 **애플리케이션의 기동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 함**<br>
왜냐면, 정적 메소드인 main()에서 DI를 사용해 오브젝트를 주입 받을 방법이 없기 때문

정리 
```
의존관계 주입 : 의존하는 오브젝트와 의존을 받는 오브젝트가 모두 스프링 빈이어야 함
의존관계 검색 : 검색하는 오브젝트는 스프링 빈일 필요가 없음 단, 의존 받는 오브젝트는 스프링의 빈이어야 함
```




