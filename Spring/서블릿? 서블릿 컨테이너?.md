
### 서블릿 (Servlet)
- JAVA로 개발한 웹 애플리케이션을 실행하기 위한 표준 인터페이스/클래스 
- `javax.servlet.Servlet` (현재는 `jakarta.servlet.Servelt`) 인터페이스가 표준의 핵심
- HTTP 요청/응답을 처리할 수 있게 해주는 자바 표준

서블릿의 역할
- 클라이언트(브라우저)에서 들어온 요청을 받고 -> 자바 코드로 처리 -> 응답을 돌려주는 역할
- 서블릿은 직접 소켓을 열고 HTTP 파싱하는게 아님 (Tomcat같은 WAS가 해줌)
- 서블릿은 Tomcat이 전달해준 Request / Response 객체를 받아서 처리하는 자바 클래스

동작 과정
1. 클라이언트가 HTTP 요청을 보냄 (GET / hello)
2. Tomcat Connector가 요청 수신, HTTP 파싱 -> `HttpServletReuqest / HttpServletResponse` 객체 생성
3. 서블릿 컨테이너가 URL 매핑 보고 적절한 Servlet 클래스 실행
4. 서블릿이 요청 처리 -> 응답 작성
5. Tomcat이 결과를 클라이언트에게 전송

```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/plain");
        response.getWriter().write("Hello Servlet!");
    }
}
```

그러면 Servlet도 DispatcherServlet도 전부 Tomcat이 전달해준 요청 / 응답을 자바 코드로 바꿔주는 역할인가? 

Servlet과 Spring MVC의 관계 
- Spring MVC의 DispatcherServlet도 결국 서블릿의 한 종류
	- 일반 서블릿은 "/hello -> HelloServlet" 이런식을 직접 매핑 
	- DispatcherServlet은 프론트 컨트롤러 패턴을 사용해서 모든 요청을 먼저 받고 -> Spring이 관리하는 컨트롤러로 위임하는 구조

즉, 
- 서블릿 : 자바 표준 인터페이스
- DispatcherServlet : Spring MVC에서 구현한 특수한 서블릿
- Tomcat : 서블릿을 실행시켜주는 컨테이너 

### 서블릿 컨테이너(Servlet Container)

서블릿을 실행해주는 환경/엔진 -> 서블릿을 관리하고 실행해주는 프로그램

역할 
1. 서블릿 생명주기 관리 
	1. 객체 생성 -> init() 호출 -> 요청마다 serivce() 실행 -> 종료시 destroy() 호출
2. 요청 / 응답 객체 생성
	1. 클라이언트 요청을 파싱해서 `HttpServletRequest` / `HttpServletResponse`를 만들어 서블릿에게 전달
3. 멀티 스레드 지원
	1. 요청마다 워커 스레드를 할당해 병렬처리 (Tomcat)
4. 보안/세션 관리

#### 서블릿 컨테이너(Tomcat)의 스레드(Thread)

그러면 여기서 또 궁금해지는게 `멀티 스레드`를 지원하는 경우는 JVM에서 돌아가서 그러는 걸까? 

JVM 자체는 스레드를 지원한다.
- 자바는 원래부터 Thread 클래스를 제공, JVM위에 OS 스레드를 사용할 수 있음
하지만 `스레드 관리`는 컨테이너(Tomcat)가 한다. 
- 서블릿 컨테이너는 클라이언트의 요청이 들어올 때마다 새 스레드를 직접 만드는 것이 아니라 `thread pool`을 만들어서 관리함 
- 요청 1개당 워커 스레드 1개가 할당돼서 처리됨
- 작업이 다 끝나면 스레드는 풀에 반환돼 재사용

JVM의 스레드 지원은 단순 스펙의 개념이고 Tomcat이 운영 정책(스레드 풀, 큐잉, 타임아웃)으로 관리
- JVM : 스레드 만들고 쓸 수 있는 능력 제공
- Tomcat(서블릿 컨테이너) : HTTP 요청을 멀티스레드로 처리하는 구조를 구현 

Tomcat에서의 역할
- 웹 애플리케이션은 수많은 요청이 동시에 들어옴 -> 요청마다 new Thread()하면 서버가 터질지도 몰라..
- 그래서 Tomcat은 스레드풀을 미리 만들어두고 요청마다 `할당`/`재사용`하는 구조로 동작
- 즉, Tomcat에서는 스레드에 대한 정책만을 관리함 

