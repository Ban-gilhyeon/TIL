
## 파티셔너

- 카프카의 토픽은 성능 향상을 위한 `병렬처리`가 가능하도록 파티션을 나눔 
	- 최소 1, 2 이상의 파티션으로 구성됨
- 전송한 메세지는 해당 토픽 내 각 **파티션의 로그 세그먼트**에 저장
- 프로듀서는 토픽으로 메세지를 보낼 때 해당 토픽의 어느 파티션으로 보낼지 결정, 이 때 사용하는 것이 **파티셔너**
- 프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 메세지(레코드)의 키를 해시 처리해 파티션을 구하는 방식을 사용 따라서 메세지의 키값이 동일하면 해당 메세지를은 모두 같은 파티션으로 전송
- 예상치 못한 많은 양의 메세지가 카프카로 인입되는 경우, 클라이언트의 처리량을 높이기 위해 토픽의 파티션을 늘릴 수 있는 기능 제공 
  (파티션 수가 변경됨과 동시에 메시지의 키와 매핑된 해시 테이블도 변경)
- 전송된 레코드들은 프로듀서의 **버퍼 메모리 영역에서 대기한 후 `최소 레코드의 수`를 충족(배치 처리)한 후 카프카로 전송** 

## 라운드 로빈 전략
CPU 스케쥴링 방법 중 하나 
- 프로세스 간에 우선순위를 두지 않고, 순서대로 시간 단위로 CPU를 할당하는 스케쥴링 알고리즘
![[Pasted image 20250117014821.png]]
프로듀서의 메세지 중 레코드의 키 값은 필숫값이 아니므로, 관리자는 별도의 레코드 키 값을 지정하지 않고 메세지를 전송할 수 있음.
키 값을 지정하지 않는다면 키 값은 `null`이 되고, 기본값인 라운드 로빈 알고리즘을 사용해 토픽의 파티션들로 랜덤 전송함 
- 레코드 1 -> 파티션 0
- 레코드 2 -> 파티션 1
- 레코드 3 -> 파티션 2
- 레코드 4 -> 파티션 0
- 레코드 5 -> 파티션 1
레코드들을 공평하게 순차적으로 나눠줌 
**배치 처리를 위해 잠시 메세지들이 대기하는 과정(최소 레코드 수를 충족하기 위해)에서 라운드 로빈 전략은 효율을 떨어뜨릴 수 있음**

그렇다고 옵션을 설정해 즉시 카프카로 레코드를 전송한다? 
이는 배치와 압축효과를 얻지 못함 **비효율적임**

## 스티키 파티셔닝 전략
하나의 파티션에 레코드 수를 먼저 채워 카프카로 빠르게 배치 전송하는 전략 

![[Pasted image 20250117031000.png]]
프로듀서는 키 값이 null인 레코드를 확인하고 배치를 위해 
- 레코드 1 -> 임의의 토픽 A-파티션 0 
- 레코드 2 -> 임의의 토픽 A-파티션 0
파티셔너는 배치를 위한 레코드 수에 도달할 때까지 다른 파티션으로 보내지 않고 동일한 파티션으로 레코드를 담아놓음 
최소 레코드 수를 충족하면 즉시 카프카로 배치 전송 
**기본 설정에 비해 30% 이상 지연시간 감소, 프로듀서의 CPU 사용률도 줄어듬**
- 카프카의 메세지 순서가 중요하지 않다면 스티키 파티셔닝 전량 권장

**주의**
- buffer.memory > batch.size
### 프로듀서의 배치
프로듀소는 배치 전송을 위해 다음과 같은 옵션을 제공
- buffer.memory : 
	- 전송을 위해 메세지들을 담아두는 프로듀서의 버퍼 메모리 옵션
	- 파티션 0, 1, 2 를 모두 포함하는 부분
	- 기본 값은 32MB 관리자 필요에 따라 설정값 조정 가능
- batch.size :
	- 메세지들을 묶는 단위를 설정하는 배치 크기 옵션
	- 파티션 내부의 작은 박스 부분
	- 기본 값은 16KB, 크기 조정 가능
- linger.ms :
	- 배치 전송을 위해 버퍼 메모리에서 대기하는 메세지들의 `최대 대기 시간`을 설정하는 옵션
	- 단위는 ms이며 기본 값은 0 (즉시전송)
처리량을 높이려면 `batch.size`와 `linger,ms`의 값을 크게 설정
지연 없는 전송이 목표라면 작게 설정해야 함
`배치 전송`과 `압축 전송`을 같이 사용하면 더욱 효율적인 전송 가능 

### 중복 없는 전송

*멱등성 : 동일한 작업을 여러번 수행하더라도 겨로가가 달라지지 않는 것을 의미*

메세지 전송 방식
1. 적어도 한번 전송
2. 최대 한번 전송
3. 중복 없는 전송

#### 적어도 한번 전송 
![[Pasted image 20250117031118.png]]
 1. 프로듀서가 브로커의 특정 토픽으로 메세지 1(A)를 전송
 2. 브로커는 메세지 1(A)를 기록하고, ACK를 프로듀서에게 응답
 3. ACK를 받은 프로듀서는 다음 메세지 2(B)를 전송
 4. 브로커는 메세지 2(B)를 기록하고 ACK 중 네트워크 오류, 브로커 장애 발생 ACK 전송 실패 
 5. 메세지 B 전송 후 브로커로 부터 ACK를 받지 못한 **프로듀서는 메세지 2(B)를 받지 못했다고 판단 재전송
	 1. ACK를 받지 못했으므로 브로커가 메세지 2(B)를 못받았을 것이라고 판단
	 2. 4번 과정에서 브로커는 메세지 2(B)를 기록했으므로, 장애에서 복구된 브로커는 메세지 2(B)를 갖고 있을 것임
	 3. 하지만 프로듀서 입장에서는 알 수 없음 -> 재전송 -> 메세지 2(B)는 중복 저장 됨

#### 최대 한번 전송 
`적어도 한번 전송`과 다르게 메세지 유실을 신경쓰지 않고 바로 다음 메세지 전송 방식 (ACK를 신경쓰지않음)
![[Pasted image 20250117032136.png]]
1. 프로듀서가 브로커의 특정 토픽으로 메세지 1 전송
2. 브로커는 메세지 1 기록, ACK 응답
3. 프로듀서는 다음 메세지 2 전송
4. 브로커는 메세지 2를 기록하지 못하고, ACK 전송 실패
5. 프로듀서는 브로커가 메세지2를 받았다고 가정하고 메세지 3전송
**메세지 중복 가능성을 회피하기 위해 최대 재전송 X**
일부 메세지가 손실되더라도 높은 처리량을 필요로하는 대량의 로그 수집이나 IoT같은 환경에서 사용

#### 중복 없는 전송
`최소 한번 전송`과 동일하지만 프로듀서가 메세지 2를 다시 전송한 후 브로커의 동작에 차이가 있음
프로듀서가 재전송한 메세지 2의 헤더에서 PID(프로듀서 아이디 : 0)와 메세지 번호(1)을 비교하여 메세지 2가 이미 메모리에 저장되어 있는 것을 확인 브로커는 중복 저장하지 않고 ACK만 전송 

![[Pasted image 20250117035248.png]]

1. 프로듀서가 브로커의 특정 토픽으로 메세지 1전송
	1. PID (0)과 메세지 번호0을 헤더에 포함하여 함께 전송
2. 브로커는 메세지1를 저장, PID와 메세지 번호를 메모리에 기록, ACK응답
3. 프로듀서는 다음 메세지 2 전송, PID는 동일 메세지 번호는 1증가하여 1
4. 브로커는 메세지2를 저장하고, PID와 메세지 번호1을 메모리에 기록 , ACK 응답 실패
5. ACK응답을 받지 못한 프로듀서는 메세지 2 재전송
6. 브로커는 메세지 2를 받지만 PID와 메세지 번호 1를 비교하여 메세지2가 이미 저장되어 있는 것을 확인, 메세지를 저장하지 않고 ACK응답만 전송 
메세지번호를 시퀀스 번호라고도 함 
중복을 피하기 위한 메세지 비교 동작에서 오버헤드가 존재, 최대 약 20%정도 성능 감소

##### 중복 없는 전송을 위한 프로듀서 설정
| 프로듀서 옵션                               | 값    | 설명                                                                                              |
| ------------------------------------- | ---- | ----------------------------------------------------------------------------------------------- |
| enable.idempotence                    | true | - 중복없는 전송을 허용할지 결정하는 옵션, 기본 값은 false<br>- true로 변경 시 다음에 나오는 옵션들도 반드시 변경해야 함 ConfigException 발생 |
| max.in.flight.requests.per_connection | 1~5  | - ACK를 받지 않는 상태에서 하나의 커넥션에서 보낼 수 있는 최대 요청 수                                                     |
| acks                                  | all  | - 프로듀서 acks와 관련된 옵션<br>- 기본값은 1이며 all로 설정해야 됨                                                   |
| retries                               | 5    | - ACK를 받지 못한 경우 재시도를 해야하므로 0보다큰 값으로 설정해야 함                                                      |
|                                       |      |                                                                                                 |

`producer.config` 파일 설정 
```
enavle.idempotence =true
max.in.flight.request.per.connection =5
retriess = 5
```

명령어 
`kafka-console-producer.sh --bootstrap-server peter-kafka01 localhost:9092 --topic peter-test04 --producer.config /opt/bitnami/kafka/bin/producer.config`

출력 
`ConfigException` 발생 `acks = all` 를 producer.config파일에 설정 안했기 때문

### 정확히 한 번 전송
