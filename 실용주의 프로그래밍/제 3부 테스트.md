커버리지를 올리기 위한 `mock` 프레임워크 사용법만 고민하고, 왜 테스트를 해야하고, 어떻게 테스트를 해야하는지 고민하지 않았음 

- 수동 테스트
	- 사람이 직접 손으로 테스트를 하고 결과값을 봄
- 자동 테스트
	- 테스트 코드를 작성하여 컴퓨터가 알아서 테스트를 하고 실패 시 에러나 예외를 발생해 개발자가 알아챌 수 있게 신호를 보냄

## Regression
-  시스템에서 정상적으로 제공하던 기능이 어떤 배포 시점을 기준으로 제대로 동작하지 않게 되는 상황
- 기능 개발이 제대로 돼 있지 않던 과거로 되돌아갔다(회귀)라는 의미 
- Regression bug로 부르는게 좀 더 정확함 
- 발생 경위
	- 개발자가 바뀌면서 이전에 작업했던 코드의 의미를 모르고 수정하면서 주로 발생
	- 위의 이유 때문에 담당자가 바뀐 코드를 수정할 때 소극적
	- 악순환 반복
- 예방법
	- JAVA DOC : 주석을 열심히 달자 
	- 테스트 코드를 작성 -> 코드의 의미를 보여줌 

레거시 코드 :  테스트가 작성이 안된 코드
## 테스트 3분류
- Large 테스트(Api 테스트 / 전체 테스트의 5%)
	- 멀티 서버 
	- End to end 테스트 
- Medium 테스트(통합 테스트 /전체 테스트의 15%)
	- 단일 서버 
	- 멀티프로세스
	- 멀티 스레드 ->  결과가 다를 수 있음
	- h2같은 테스트 DB를 사용할 수 있다
- **samll 테스트(단위 테스트 / 전체 테스트의 80%)
	- 테스트 결과가 항상 결정적(Deterministic)
	- 테스트 속도 빠름
	- 단일 서버
	- 단일 프로세스
	- 단일 스레드
	- 디스크 I/O 사용 X 
	- Blocking call X 


## 테스트 
#### 좋은 테스트의 기준
- 테스트는 결정적이여야 함
	- 결정적이다 = 일관성을 가진다, 동일한 입력에는 동일한 테스트 결과를 가져와야 함
	- 비결정적이다 = 코드를 수정하지 않았는데 결과가 다를 때 (외부 DB 같은 곳에서 오류가 생겨서 실패할 수도 있음)
		- 병렬처리를 사용할 경우
		- 디스크I/O를 사용할 경우
		- 다른 프로세스와 통신할 경우
		- 외부 서버와 통신할 경우
- 테스트의 속도는 빠르게 
	- 속도가 느린 테스트가 만들어지는 경우
		- 블로킹 호출을 사용할 경우 (`Thread.sleep()`)
		- 디스크 I/O를 사용할 경우 (입력/출력을 기다려야겠지?)
		- 다른 프로세스와 통신할 경우
		- 외부 서버와 통신할 경우 
- 이러한 이유로 small 테스트는 금기 사항들이 있음 

#### 테스트 대역
: 스턴트맨 같은 대역임, 테스트를 위해 만들어진 가짜 객체나 컴포넌트 
- Dummy : 빈 깡통
	- 정상적으로 코드가 돌아가게 하기 위한 역할만 
	- 없으면 NPE 발생할 때 그냥 Dummy 만들어서 처리 
- Stub : 지정한 값만 반환 (`when().thenReturn`)
	- 사본과 거의 같은 개념
	- 실체 객체의 응답을 최대한 비슷하게 따라하는 대역
	- 응답을 원본과 똑같이 반환하는데만 집중
- Fake : 자체적인 로직이 있음
	- 모든 테스트에 Stub을 사용하는 코드를 넣기 힘들고 바람직하지도 않음 -> 테스트의 중요한 부분을 가릴 수 있기 때문에
	- 최대한 간결하고 보자마자 이해 가능한 형태로 작성해야 함 Fake 사용 지향
	- 데이터 저장을 간단한 메모리 변수를 갖고 있게 함
- Mock : 아무런 동작을 하지 않음, 대신 어떤 행동이 호출됐는지 기록
	- 메서드 호출 및 상호작용 기록
	- 어떤 객체와 상호 작용이 일어났는지 기록
	- 어떻게 상호작용이 일어났는지 기록
	- Mock은 테스트 대역의 부분 집합
		- 관용적인 의미
			- 테스트 대역과 거의 같은 의미 
		- 개념적인 의미
			- 메서드 호출이 발생했는지를 검증하기 위해 만들어지는 테스트 대역에 해당
			- assertOO 짝꿍
	- 인터페이스를 구현해서 Mock객체를 구현 (@Mock 쓰면 됨 ㅎ)
- Spy : 실제 객체와 똑같이 행동, 모든 행동 호출 기록 
	- 구현체를 가지고 있음
	- 상속을 이용해서 구현(@Spy 쓰면 됨 ㅎ)
	- 프록시 패턴을 이요해서 구현 
```java
//Mock과 Spy의 차이 
@Test
public void mock_versus_spy(){
	//given
	List<Integer> mockList = Mockito.mock(ArrayList.class);
	List<Integer> spyList = Mockito.spy(new ArrayList<Integer>());

	//when
	mockList.add(1);
	spyList.add(1);

	//then.1 둘다 메소드는 호출 됨
	verify(mockList).add(1);
	verigy(spyList).add(1);

	//then.2 진짜 추가 된건 spy만
	assertEquals(mockList.size(), 1) // fail
	assertEquals(spyList.size(),1) // success
}
```

##### 상태 기반 검증 
: 테스트를 실행한 후 테스트 대상의 상태가 어떻게 변화 됐는지 보고 테스트 실행 결과를 판단
```java
@Test
void 유저는_북마크를_toggle_해서_제거할_수_있다(){
//given 
	User user = UserFixture.create();
	user.appendBookmark("foobar"); // bookmark 추가
//when
user.toggleBookmark("foobar"); //bookmark 삭제

//then
//제거 했으니 갖고 있으면 안됨
assertTaht(user.hasBookamrk("foobar")).isFalse();
}
```
##### 행위 기반 검증
: 테스트 검증 동작에 메서드 호출 여부를 보고 판단
- 상호작용 테스트라고도 함 -> 상호작용이란 객체간의 협력
```java
@Test
void 유저는_북마크를_toggle_해서_제거할_수_있다(){
//given
User user = UserFixture.create();
user.appendBookmark("foobar");

//when
user.toggleBookmark("foobar");

//then
verify(user).removeBookmark("foobar"); // removeBookmark()가 호출 됐는지 검증
}
```

행위기반 검증보다 상태기반 검증을 더 지향함 
- 상호작용 테스트가 많아지면 코드가 전체적으로 경직될 수 있음
- 현재 코드 외에 다른 방법으로 개발하는 것이 불가능 -> 서비스 로직 수정할 때 곤란
**테스트 대역을 잘 사용하려면 추삭화가 잘 돼 있어야함 -> 의존성 역전을 잘 해놔야 함
- 테스트 대역을 순수 자바 코드로 작성하려고 했을 대 난황
	- `JpaRepositroy`를 다 구현 해야 함..
	- 라이브러리와 더 강하게 결합하는 형태가 될 수 있음 

##### 테스트 가능성(Testalbility) 
- 테스트 하기 쉬운 코드면 테스트 가능성이 높다
- 반대로 어려우면 가능성이 낮다
숨겨진 입력 ( p.390 한번 더 보기 )
- 랜덤 요소, 시간을 다루는 코드 등 전역 메소드에 의존하는 상황
- getter로 숨겨진 입력을 드러나게 작성 
- 의존성 주입과 의존성 역전을 동시에 사용하는 것 
- 책임에 의존하면 같은 코드를 실행하면서 환경에 따라 컴포넌트를 갈아끼울 수 있게 됨
숨겨진 출력 (p. 401)
- print, log 를 출력하는 경우 Return값은 따로 
- 메소드 구현에 전역 변수를 변경하는 경우
- 메소드 호출의 출력 결과는 반환 값을 통해 드러나는 것이 좋음 -> DTO를 반환하면 얼추 가능
- 이벤트라는 클래스를 만들고 메서드의 반환 값으로 이벤트를 반환 -> DTO랑 뭐가 다르지..?